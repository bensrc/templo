// TODO: all parameter list must be divided by a comma (search for List.iter

/*
 *  Templo compiler
 *  Copyright (c)2008 Motion-Twin
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License or the LICENSE file for more details.
 */
open Lexer;
open Templo.Ast;
open Neko.Ast;

type context {
	mutable temp_counter : int;
	buffer : Buffer.t;
	mutable inphp : bool;
	mutable blocks_closing : string list;
	mutable call_level : int;
}

function php_op(o) {
	var s = s_op(o);
	match s {
	| "!=" -> "!=="
	| "==" -> "==="
	| s -> s
	}
}

function cdata(ctx,s) {
	if ctx.inphp then {
		Buffer.add(ctx.buffer," ?>\n");
		ctx.inphp := false;
	}
	Buffer.add(ctx.buffer,s);
}

function php(ctx,s) {
	if !ctx.inphp then {
		Buffer.add(ctx.buffer,"<?php ");
		ctx.inphp := true;
	}
	Buffer.add(ctx.buffer,s);
}

function temp(ctx) {
	var tmp = "$t"+ctx.temp_counter;
	ctx.temp_counter := ctx.temp_counter+1;
	tmp;
}

function repeater(v) {
	"$repeater_"+v;
}

function escape_single_quote(s) {
	var b = Buffer.create();
	function rec loop(i) {
		if i == String.length s then
			Buffer.string b
		else {
			match String.get s i {
			| '\'' -> Buffer.add b "\\'"
			| c -> Buffer.add_char b c
			};
			loop (i+1)
		}
	};
	loop(0);
}

function rec gen_ast_expr(ctx,e) {
	var p = snd e;
	match fst e {
	| VConst c ->
		match c {
		| CInt i -> php ctx i
		| CFloat f -> php ctx f
		| CString s -> php(ctx,"'"+escape_single_quote(s)+"'") // TODO: escape this
		}
	| VIdent "true" -> php ctx "true"
	| VIdent "false" -> php ctx "false"
	| VIdent "null" -> php ctx "null"
	| VIdent i -> php(ctx,"$ctx->"+i)
	| VVar v -> php(ctx,"$_"+v)
	| VIf (e1,e2,e3) -> 
		gen_ast_expr(ctx, e1);
		php(ctx," ? ");
		gen_ast_expr(ctx, e2);
		php(ctx," : ");
		(match e3 {
		| Some e ->
			gen_ast_expr(ctx, e);
		| _ -> 
			php(ctx,"null");
		});
	| VBinop (op,e1,e2) -> 
		gen_ast_expr(ctx,e1);
		php(ctx," "+php_op(op)+" ");
		gen_ast_expr(ctx,e2);
	| VUnop (op,pref,e) ->
		match op {
		| Increment ->
			if pref then php(ctx,"++");
			gen_ast_expr(ctx,e);
			if !pref then php(ctx,"++");
		| Decrement -> 
			if pref then php(ctx,"--");
			gen_ast_expr(ctx,e);
			if !pref then php(ctx,"--");
		| Not -> 
			php(ctx,"!");
			gen_ast_expr(ctx,e);
		| Neg -> 
			php(ctx,"-");
			gen_ast_expr(ctx,e);
		}
	| VCall (e,el) -> 
		gen_ast_expr(ctx,e);
		ctx.call_level := ctx.call_level + 1;
		php(ctx,"(");
		gen_ast_expr_params ctx el;
		php(ctx,")");
		ctx.call_level := ctx.call_level - 1;
	| VParent e -> 
		php(ctx,"(");
		gen_ast_expr(ctx,e);
		php(ctx,")");
	| VField ((VIdent "repeat",_),k) -> 
		php(ctx, repeater(k))
	| VField (e,v) -> 
		gen_ast_expr(ctx,e);
		php(ctx,"->"+v);
	| VArray (e1,e2) ->
		gen_ast_expr(ctx,e1);
		php(ctx,"[");
		gen_ast_expr(ctx,e2);
		php(ctx,"]");
	| VArrayDecl el ->
		php(ctx,"array(");
		gen_ast_expr_params ctx el;
		php(ctx,")");
	| VBool e ->
		//false , null and 0
		php(ctx,"templo_is_true(");
		match fst e {
		| VParent e ->
			gen_ast_expr(ctx,e);
		| _ ->
			gen_ast_expr(ctx,e);
		}
		php(ctx,")");
	}
}

function rec gen_ast_expr_params(ctx,el) {
	match el {
	| [] -> 
		()
	| e :: [] ->
		gen_ast_expr(ctx,e);
	| e :: el ->
		gen_ast_expr(ctx,e);
		php(ctx,", ");
		gen_ast_expr_params(ctx,el);
	}
}


function open_block(ctx,close_string) {
	ctx.blocks_closing := close_string :: ctx.blocks_closing
}

function close_block(ctx) {
	match ctx.blocks_closing {
	| [] -> ()
	| s :: sl ->
		if s != "" then php(ctx, s);
		ctx.blocks_closing := sl
	}
}

function gen_foreach(ctx,v,e) {
	php(ctx, repeater(v)+" = new templo_repeater(");
	gen_ast_expr(ctx,e);
	php(ctx, "); ");
	php(ctx, " while("+repeater(v)+"->hasNext()): ");
	php(ctx, "$_" + v + " = " + repeater(v) + "->next(); ");
	open_block(ctx,"endwhile;");
}

function gen_const_expr(ctx,e) {
	match e {
	| CValue e ->
		if ctx.call_level == 0 then 
			php(ctx, "echo ");
		php(ctx, "htmlspecialchars(");
		gen_ast_expr(ctx,e);
		php(ctx, ")"); // TODO: check this is consistent with neko for quotes and char replacements
		if ctx.call_level == 0 then 
			php(ctx, ";");
	| CRaw e ->
		if ctx.call_level == 0 then 
			php(ctx, "echo ");
		gen_ast_expr(ctx,e);
		if ctx.call_level == 0 then 
			php(ctx, ";");
	| CIf e ->
		php(ctx, "if(");
		gen_ast_expr(ctx,e);
		php(ctx, "):");
		open_block(ctx,"endif;");
	| CElseIf e ->
		php(ctx, "elseif(");
		gen_ast_expr(ctx,e);
		php(ctx, "):");
	| CElse ->
		php(ctx, "else:");
	| CForeach (v,e) ->
		gen_foreach(ctx,v,e);
	| CFill v ->
		php(ctx, "ob_start();");
		open_block(ctx,"$_"+v+" = ob_get_contents(); ob_end_clean();");
	| CUse file ->
		php(ctx, "include dirname(__FILE__).'/'.");
		gen_ast_expr(ctx,file);
		php(ctx, ".'.php';");
	| CSet (v,e) ->
		php(ctx,"$_"+v+" = ");
		gen_ast_expr(ctx,e);
		php(ctx,";");
	| CEval e ->
		gen_ast_expr(ctx,e);
		php(ctx,";");
	| CEnd ->
		close_block(ctx);
	}
}

function rec generate_attr(ctx,p,(n,content)) {
	cdata(ctx, " " + n + "=\"");
	List.iter generate_element(ctx) content;
	cdata(ctx, "\"")
}

function rec gen_var_params(ctx,sl) {
	match sl {
	| [] -> 
		()
	| s :: [] ->
		php(ctx,"$_"+s);
	| s :: sl ->
		php(ctx,"$_"+s);
		php(ctx,", ");
		gen_var_params(ctx,sl);
	}
}

function rec gen_macro_call(ctx,name,params) {
	ctx.call_level := ctx.call_level+1;
	php(ctx, "macro_" + name + "(");
	generate_element_params ctx params;
	php(ctx, ");");
	ctx.call_level := ctx.call_level-1;
}

function rec generate_element_params(ctx,el) {
	match el {
	| [] -> 
		()
	| e :: [] ->
		List.iter generate_element(ctx) e;
	| e :: el ->
		List.iter generate_element(ctx) e;
		php(ctx,", ");
		generate_element_params(ctx,el);
	}
}

function rec generate_element(ctx,e) {
	var p = snd e;
	match fst e {
	| XNode n ->				
		match n.n_repeat {
		| None -> 
			open_block(ctx,"")
		| Some (v,e) ->
			gen_foreach(ctx,v,e)
		};
		
		match n.n_cond {
		| None -> open_block(ctx,"")
		| Some cond -> 
			php(ctx," if(");
			gen_ast_expr(ctx,cond);
			php(ctx,"):");
			open_block(ctx," endif;")
		};
		
		cdata(ctx, "<" + n.n_node);
		List.iter (function((name,_,params)){ gen_macro_call ctx name params }) n.n_macros;
		List.iter generate_attr(ctx,p) n.n_attributes;

// TODO: check this matches the neko implementation
		List.iter (function((attr,e)) {
			var etmp = temp ctx;
			php(ctx,etmp+" = ");
			gen_ast_expr(ctx,e);
			php(ctx,"; if(templo_is_true("+etmp+")");
			php(ctx," echo ' " + attr + "=\"'." + etmp + ".'\"'; ");
		}) n.n_attrs;

		match n.n_content {
		| None -> 
			cdata(ctx,"/>")
		| Some cl ->
			cdata(ctx,">");
			List.iter generate_element(ctx) cl;
			cdata(ctx,"</"+n.n_node+">")
		};
		close_block(ctx);
		close_block(ctx);
	| XMacroCall (name,params) ->
		gen_macro_call ctx name params
		/*
		ctx.call_level := ctx.call_level+1;
		php(ctx, "macro_" + name + "(");
		generate_element_params ctx params;
		php(ctx, ");");
		ctx.call_level := ctx.call_level-1;
		*/
	| XMacroDef m ->
		php(ctx, "\nfunction macro_" + m.m_name + "(");
		gen_var_params ctx m.m_args;
		php(ctx, ") {\n");
		open_block(ctx, "\n}\n");
		match m.m_content {
			| MContent c ->
				List.iter generate_element(ctx) c;
			| MAttr a ->
				List.iter generate_attr(ctx,p) a;
		};		
		close_block(ctx);
	| XComment c ->
		cdata(ctx, c)
	| XData d ->
		cdata(ctx, d)
	| XCData content ->
		cdata(ctx, "<![CDATA[");
		List.iter generate_element(ctx) content;
		cdata(ctx, "]]>")
	| XConstr e ->
		gen_const_expr(ctx,e);
	}
}

function generate_template(ctx, content) {
	generate_element(ctx, content);
}

function generate_file(output,(file,content,imports)) {
	var p = {
		psource = file;
		pline = 0; pmin = 0; pmax = 0;
	};
// TODO: macros
// TODO: imports
/*	
	macros := [];
	var macros = List.rev (*macros);
*/
	var ctx = {
		temp_counter = 0;
		buffer = Buffer.create();
		inphp = false;
		blocks_closing = [];
		call_level = 0;
	};
	List.iter generate_template(ctx) content;
	cdata(ctx,""); // closes opened php when required
	
	var fout = output + file + ".php";
	var ch = IO.write_file fout true;
	IO.write ch Buffer.string(ctx.buffer);
	IO.close_out ch;
}

function generate(output,debug,files) {
	List.iter generate_file(output) files
}
