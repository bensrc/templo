/*
 *  Templo compiler
 *  Copyright (c)2008 Motion-Twin
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License or the LICENSE file for more details.
 */
open Templo.Ast;

type macro_file {
	file : string;
	mutable used : bool;
}

type macro_kind {
	MKAttributes;
	MKContent;
	MKValue;
}

type macro_type {
	margs : int;
	mkind : macro_kind;
	mfile : macro_file option;
}

type checker {
	mutable stack : (construct, pos, string list) list;
	mutable vars : string list;
	mutable macro_files : macro_file list;
	mutable macros : (string, macro_type) Map.t;
	mutable in_attrib : bool;
}

exception Error : (string, pos);

var r_empty = Regexp.build "^[ \t\r\n]*$";
var r_quote = Regexp.build "\"";

function is_empty(str) {
	Regexp.find r_empty str 0 String.length(str)
}

function error(msg,pos) {
	throw Error(msg,pos)
}

function init() {
	{
		stack = [];
		vars = [];
		macro_files = [];
		macros = Map.empty();
		in_attrib = false;
	}
}

function add_macro(chk,m,file) {	
	// we don't allow nodes and double-quotes in macro content that is used for attributes values
	function rec loop(e) {
		match fst e {
		| ENode _ | EComment _ | ECData _ | EMacroDef _ -> throw Exit
		| EMacroCall (_,params) ->
			// we can't check atm what is the content of the called macro			
			List.iter (function(p) List.iter loop p) params
		| EData str ->
			if Regexp.find r_quote str 0 String.length(str) then throw Exit;
		| EConstr _ -> ()
		}
	}
	var kind = match m.m_content {
		| MContent el -> (try { List.iter loop el; MKValue; } catch { Exit -> MKContent })
		| MAttr _ -> MKAttributes
	}
	var md = {
		margs = List.length m.m_args;
		mkind = kind;
		mfile = file;
	};
	chk.macros := Map.add chk.macros m.m_name md;
}

function add_macros(chk,file,el) {
	var file = { file = file; used = false };
	chk.macro_files := file :: chk.macro_files;
	var macros = &[];
	function rec loop(e) {
		match fst e {
		| ENode n when n.n_node == "macros" ->
			match n.n_content {
			| None -> ()
			| Some c -> List.iter loop c
			}
		| EMacroDef m ->
			macros := (EMacroDef m,snd e) :: *macros;
			add_macro chk m Some(file)
		| EComment _ -> ()
		| EData r when is_empty r -> ()
		| _ -> error "This is not allowed in a macro file" snd(e)
		}
	}
	List.iter loop el;
	List.rev (*macros)
}

function add_variable(chk,v,p) {
	if List.mem v chk.vars then error ("Variable " + v + " is used several times") p;
	chk.vars := v :: chk.vars
}

function check_expr(chk,e) {
	function rec loop(e) {
		(match fst e {
		| EIdent i when List.mem i chk.vars -> EVar i
		| EIf (e,e1,e2) -> EIf loop(e) loop(e1) (match e2 { None -> None | Some e -> Some (loop e) })
		| EBinop (op,e1,e2) -> EBinop op loop(e1) loop(e2)
		| EUnop (op,prefix,e) -> EUnop op prefix loop(e)
		| ECall (e,el) -> ECall loop(e) (List.map loop el)
		| EParent e -> EParent loop(e)
		| EField (e,f) -> EField loop(e) f
		| EArray (e1,e2) -> EArray loop(e1) loop(e2)
		| EArrayDecl el -> EArrayDecl (List.map loop el)
		| EConst _ | EIdent _ | EVar _ -> fst e
		},snd e)
	}
	loop e
}

function rec check_macro(chk,name,kind,params,pos) {
	var m = (try Map.find chk.macros name catch { Not_found -> error ("No such macro "+name) pos });
	if List.length params != m.margs then error ("Macro "+name+" needs "+List.length(params)+" parameters") pos;
	match m.mfile {
	| None -> ()
	| Some f -> f.used := true
	}
	match (m.mkind,kind) {
	| (MKAttributes, MKAttributes) -> ()
	| (MKValue,MKContent) | (MKValue,MKValue) -> ()
	| (MKContent,MKContent) -> ()
	| (_,MKAttributes) -> error ("Macro "+name+" cannot be called here : please put attributes directly after macro name") pos
	| _ -> error ("Macro "+name+" cannot be called here because the result would not be XHTML") pos
	}
	function rec trim(e) {
		match e {
		| (EData r,_) :: e when is_empty r -> trim e
		| _ -> e
		}
	}
	List.map (function(el) {
		var el = check_content chk el;
		// trim spaces around macro params
		var el = trim el;
		var elr = trim (List.rev el);
		// remove {...} if surrounding parameter
		match el {
		| (EData "{",_) :: _ ->
			match elr {
			| (EData "}",_) :: elr -> List.tl (List.rev elr)
			| _ -> List.rev elr
			}
		| _ -> List.rev elr
		}
	}) params
}

function rec check_content(chk,el) {
	var old = chk.stack;
	chk.stack := [];
	var el = List.map (check_rec chk) el;
	match chk.stack {
	| [] -> ()
	| (v,p,_) :: _ ->
		var str = match v {
		| CIf _ -> "if"
		| CForeach _ -> "foreach"
		| CFill _ -> "fill"
		| CUse _ -> "use"
		| _ -> "???"
		}
		error ("Unclosed " + str) p
	}
	chk.stack := old;
	el
}

function rec check_rec(chk,e) {
	(match fst e {
	| ENode n ->
		var old = chk.vars;
		var repeat = match n.n_repeat {
		| None -> None
		| Some (n,e) ->
			var e = check_expr chk e;
			add_variable chk n snd(e);
			Some (n,e)
		}
		chk.in_attrib := true;
		var attr = List.map (function((name,c)) (name,check_content chk c)) n.n_attributes;
		chk.in_attrib := false;
		var n2 = {
			n_node = n.n_node;
			n_attributes = attr;
			n_macros = List.map (function((name,pos,params)) (name,pos,check_macro chk name MKAttributes params pos)) n.n_macros;
			n_cond = match n.n_cond { None -> None | Some e -> Some (check_expr chk e) };
			n_repeat = repeat;
			n_attrs = List.map (function((n,e)) (n, check_expr chk e)) n.n_attrs;
			n_content = match n.n_content { None -> None | Some c -> Some (check_content chk c) };
		}
		chk.vars := old;
		ENode n2
	| EMacroCall (name,params) ->
		var params = check_macro chk name (if chk.in_attrib then MKValue else MKContent) params snd(e);
		EMacroCall name params
	| EMacroDef m ->
		var old = chk.vars;
		List.iter (function(v) add_variable chk v snd(e)) m.m_args;
		var m = {
			m_name = m.m_name;
			m_args = m.m_args;
			m_content = match m.m_content {
				| MContent el -> MContent (check_content chk el);
				| MAttr n ->
					match check_content chk [(ENode n,snd e)] {
					| [(ENode n,_)] -> MAttr n
					| _ -> assert()
					}
			};
		};
		chk.vars := old;
		EMacroDef m
	| EComment _
	| EData _ ->
		fst e
	| ECData el ->
		ECData (check_content chk el)
	| EConstr c ->
		var cur = (c,snd e,chk.vars);
		var c = match c {
		| CValue e ->
			CValue (check_expr chk e)
		| CRaw e ->
			CRaw (check_expr chk e)
		| CSet (v,ex) ->
			if List.mem v chk.vars then error "You cannot set a local variable" snd(e);
			CSet v (check_expr chk ex)
		| CIf e ->
			chk.stack := cur :: chk.stack;
			CIf (check_expr chk e)
		| CElse ->
			match chk.stack {
			| (CIf _,_,_) :: stack | (CElseIf _,_,_) :: stack -> chk.stack := cur :: stack;
			| _ -> error "Unexpected else" snd(e)
			}
			CElse
		| CElseIf ex ->
			match chk.stack {
			| (CIf _,_,_) :: stack | (CElseIf _,_,_) :: stack -> chk.stack := cur :: stack;
			| _ -> error "Unexpected elseif" snd(e)
			}
			CElseIf (check_expr chk ex)
		| CForeach (k,ex) ->
			chk.stack := cur :: chk.stack;
			var ex = check_expr chk ex;
			add_variable chk k snd(e);
			CForeach k ex
		| CFill k ->
			if List.mem k chk.vars then error "You cannot fill a local variable" snd(e);
			chk.stack := cur :: chk.stack;
			CFill k
		| CUse e ->
			chk.stack := cur :: chk.stack;
			CUse (check_expr chk e)
		| CEnd ->
			match chk.stack {
			| [] -> error "Unexpected end" snd(e)
			| (_,_,vars) :: stack ->
				chk.vars := vars;
				chk.stack := stack;
			}
			CEnd
		}
		EConstr c
	}, snd e)
}

function run(chk,el) {
	var old = chk.macros;
	List.iter (function(f) f.used := false) chk.macro_files;
	var el = check_content chk el;
	chk.macros := old;
	(el, List.map (function(f) f.file) (List.filter (function(f) f.used) chk.macro_files))
}
